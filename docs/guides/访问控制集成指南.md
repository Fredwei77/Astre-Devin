# 访问控制系统集成指南

## 快速开始

### 第一步：引入核心文件

在所有受保护的页面（divination.html, fengshui.html, iching.html, profile.html）的 `</body>` 标签前添加：

```html
<!-- 认证服务 -->
<script src="auth-service.js"></script>

<!-- 访问控制守卫（二选一） -->
<!-- 选项1：增强版（推荐） -->
<script src="auth-guard-enhanced.js"></script>

<!-- 选项2：基础版 -->
<!-- <script src="auth-guard.js"></script> -->
```

### 第二步：测试系统

1. 打开 `test-auth-system.html` 测试页面
2. 点击"模拟登录"按钮
3. 尝试访问受保护页面
4. 观察日志输出

## 详细集成步骤

### 1. 更新 divination.html

在文件末尾 `</body>` 标签前添加：

```html
<!-- 认证系统 -->
<script src="auth-service.js"></script>
<script src="auth-guard-enhanced.js"></script>
</body>
</html>
```

### 2. 更新 fengshui.html

同样在 `</body>` 标签前添加：

```html
<!-- 认证系统 -->
<script src="auth-service.js"></script>
<script src="auth-guard-enhanced.js"></script>
</body>
</html>
```

### 3. 更新 iching.html

```html
<!-- 认证系统 -->
<script src="auth-service.js"></script>
<script src="auth-guard-enhanced.js"></script>
</body>
</html>
```

### 4. 更新 profile.html

```html
<!-- 认证系统 -->
<script src="auth-service.js"></script>
<script src="auth-guard-enhanced.js"></script>
</body>
</html>
```

### 5. 更新 login.html（登录成功后的处理）

在登录成功的回调函数中添加：

```javascript
// 登录成功后
function onLoginSuccess(token, userData) {
    // 保存认证信息
    AuthService.setAuth(token, userData, rememberMe);
    
    // 重定向到返回URL或首页
    AuthService.redirectAfterLogin();
}
```

### 6. 更新导航栏（header-auth.js 或相关文件）

添加登出功能：

```javascript
// 登出按钮点击事件
document.getElementById('logoutBtn').addEventListener('click', () => {
    if (confirm('确定要退出登录吗？')) {
        AuthService.logout();
    }
});

// 显示用户信息
function updateUserDisplay() {
    const user = AuthService.getCurrentUser();
    if (user) {
        document.getElementById('userName').textContent = user.name || user.email;
        document.getElementById('userAvatar').src = AuthService.getUserAvatar();
    }
}

// 监听认证状态变化
window.addEventListener('authStateChanged', (e) => {
    if (e.detail.isAuthenticated) {
        updateUserDisplay();
    } else {
        // 清除用户显示
        document.getElementById('userName').textContent = 'Guest';
    }
});
```

## 配置选项

### 修改守卫行为

在 `auth-guard-enhanced.js` 中修改配置：

```javascript
const CONFIG = {
    loginPage: 'login.html',        // 登录页面路径
    homePage: 'index.html',         // 首页路径
    enableLogging: true,            // 启用日志
    showPrompt: true,               // 显示登录提示框
    autoRedirect: false,            // 自动重定向
    redirectDelay: 3000             // 重定向延迟（毫秒）
};
```

### 添加新的受保护页面

在 `auth-guard-enhanced.js` 中修改：

```javascript
const PROTECTED_PAGES = [
    'divination.html',
    'fengshui.html',
    'iching.html',
    'profile.html',
    'new-page.html'  // 添加新页面
];
```

## 高级用法

### 1. 在JavaScript中检查登录状态

```javascript
// 检查是否登录
if (AuthService.isAuthenticated()) {
    console.log('用户已登录');
    const user = AuthService.getCurrentUser();
    console.log('用户邮箱:', user.email);
}
```

### 2. 要求登录后执行操作

```javascript
// 点击按钮时检查登录
document.getElementById('premiumFeature').addEventListener('click', () => {
    AuthGuard.requireAuth((user) => {
        // 用户已登录，执行操作
        console.log('执行高级功能，用户:', user.email);
        // ... 你的代码
    });
});
```

### 3. 获取认证头部（用于API请求）

```javascript
// 发送API请求时包含认证头
fetch('/api/user/profile', {
    method: 'GET',
    headers: {
        ...AuthService.getAuthHeader(),
        'Content-Type': 'application/json'
    }
})
.then(response => response.json())
.then(data => console.log(data));
```

### 4. 监听认证状态变化

```javascript
// 监听登录/登出事件
window.addEventListener('authStateChanged', (e) => {
    const { isAuthenticated, user } = e.detail;
    
    if (isAuthenticated) {
        console.log('用户登录:', user.email);
        // 更新UI
    } else {
        console.log('用户登出');
        // 清除UI
    }
});
```

### 5. 检查用户权限

```javascript
// 检查用户是否有特定权限
if (AuthService.hasPermission('admin')) {
    // 显示管理员功能
    document.getElementById('adminPanel').style.display = 'block';
}

// 检查用户角色
if (AuthService.hasRole('premium')) {
    // 显示高级功能
    enablePremiumFeatures();
}
```

## 测试清单

### 基础测试

- [ ] 未登录访问受保护页面，显示登录提示
- [ ] 点击"立即登录"跳转到登录页
- [ ] 点击"返回首页"跳转到首页
- [ ] 登录后可以正常访问受保护页面
- [ ] 登出后再次访问受保护页面被拦截

### 高级测试

- [ ] 登录后刷新页面，仍保持登录状态
- [ ] 关闭浏览器重新打开（测试localStorage）
- [ ] 在多个标签页中登出，其他标签页同步更新
- [ ] Token无效时自动清除并显示登录提示
- [ ] 返回URL功能正常工作

### 边界测试

- [ ] localStorage被禁用时的处理
- [ ] 网络错误时的处理
- [ ] 无效JSON数据的处理
- [ ] 并发请求的处理

## 常见问题

### Q1: 登录后仍然显示登录提示？

**A:** 检查以下几点：
1. 确认 `auth-service.js` 在 `auth-guard-enhanced.js` 之前加载
2. 检查浏览器控制台是否有错误
3. 验证localStorage中是否有 `destinyai_token` 和 `destinyai_user`
4. 确认用户数据格式正确（必须包含email字段）

### Q2: 如何自定义登录提示的样式？

**A:** 修改 `auth-guard-enhanced.js` 中的 `showLoginPrompt()` 函数，调整CSS样式。

### Q3: 如何禁用登录提示，直接重定向？

**A:** 在 `auth-guard-enhanced.js` 中设置：
```javascript
const CONFIG = {
    showPrompt: false,
    autoRedirect: true
};
```

### Q4: 如何集成后端API验证？

**A:** 在 `auth-service.js` 中添加API验证：
```javascript
async function validateWithBackend(token) {
    try {
        const response = await fetch('/api/auth/validate', {
            headers: { 'Authorization': `Bearer ${token}` }
        });
        return response.ok;
    } catch (error) {
        console.error('Token validation failed:', error);
        return false;
    }
}
```

### Q5: 如何处理Token过期？

**A:** 实现Token刷新机制：
```javascript
async function refreshToken() {
    const currentToken = AuthService.getToken();
    
    try {
        const response = await fetch('/api/auth/refresh', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${currentToken}`,
                'Content-Type': 'application/json'
            }
        });
        
        if (response.ok) {
            const { token, user } = await response.json();
            AuthService.setAuth(token, user, true);
            return true;
        }
    } catch (error) {
        console.error('Token refresh failed:', error);
    }
    
    return false;
}
```

## 性能优化建议

1. **延迟加载**：在页面完全加载后再执行认证检查
2. **缓存用户数据**：避免重复解析JSON
3. **最小化重定向**：使用提示框而不是立即重定向
4. **异步验证**：后端验证使用异步方式

## 安全建议

1. **HTTPS部署**：生产环境必须使用HTTPS
2. **Token加密**：考虑对token进行加密存储
3. **定期刷新**：实现token自动刷新机制
4. **后端验证**：前端验证只是第一道防线
5. **XSS防护**：避免在localStorage中存储敏感信息
6. **CSRF防护**：实现CSRF token机制

## 下一步

1. 测试所有受保护页面的访问控制
2. 集成后端API验证
3. 实现Token刷新机制
4. 添加用户权限管理
5. 优化用户体验

## 支持

如有问题，请查看：
- `页面访问控制系统设计.md` - 系统设计文档
- `test-auth-system.html` - 测试页面
- 浏览器控制台日志
